[
  {
    "id": "swiftdata_001",
    "title": "Einf√ºhrung in SwiftData",
    "description": "Lerne, wie du mit SwiftData Objekte speicherst, abrufst und automatisch in SwiftUI synchronisierst.",
    "steps": [
      "Importiere SwiftData und definiere ein @Model.",
      "Erstelle ein ModelContainer im App-Entry.",
      "Nutze @Query oder ModelContext zum Speichern und Laden von Daten."
    ],
    "colors": {
      "backgroundColors": [
        "#000000",
        "#7209B7",
        "#000000"
      ],
      "textColors": [
        "#FFFFFF"
      ]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n/ 1Ô∏è‚É£ Datenmodell definieren\n@Model\nclass Note {\n    var title: String\n    var createdAt: Date\n\n    init(title: String, createdAt: Date = .now) {\n        self.title = title\n        self.createdAt = createdAt\n    }\n}\n\n/ 2Ô∏è‚É£ Haupt-App mit ModelContainer\n@main\nstruct NotesApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .modelContainer(for: Note.self)\n    }\n}\n\n/ 3Ô∏è‚É£ Daten in SwiftUI anzeigen und speichern\nstruct ContentView: View {\n    @Environment(\\.modelContext) private var context\n    @Query private var notes: [Note]\n    @State private var newTitle = \"\"\n\n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 20) {\n                TextField(\"Neue Notiz\", text: $newTitle)\n                    .textFieldStyle(.roundedBorder)\n                    .padding()\n\n                Button(\"Speichern\") {\n                    let note = Note(title: newTitle)\n                    context.insert(note)\n                    try? context.save()\n                    newTitle = \"\"\n                }\n                .buttonStyle(.borderedProminent)\n\n                List(notes) { note in\n                    VStack(alignment: .leading) {\n                        Text(note.title)\n                            .font(.headline)\n                        Text(note.createdAt, style: .date)\n                            .font(.caption)\n                            .foregroundColor(.gray)\n                    }\n                }\n            }\n            .navigationTitle(\"SwiftData Notizen\")\n        }\n    }\n}\n\n#Preview { ContentView() }",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#0000FF"
  },
  {
    "id": "swiftdata_002",
    "title": "SwiftData Beziehungen (One-to-Many)",
    "description": "Erstelle zwei miteinander verkn√ºpfte SwiftData-Modelle ‚Äì z. B. Kategorien mit mehreren Eintr√§gen.",
    "steps": [
      "Erstelle zwei @Model-Klassen.",
      "Verkn√ºpfe sie mithilfe von @Relationship.",
      "Nutze .cascade oder .nullify f√ºr Delete Rules."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#560BAD", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass Category {\n    var name: String\n    @Relationship(deleteRule: .cascade) var items: [Item] = []\n    init(name: String) { self.name = name }\n}\n\n@Model\nclass Item {\n    var title: String\n    init(title: String) { self.title = title }\n}\n\nstruct CategoryListView: View {\n    @Environment(\\.modelContext) private var context\n    @Query private var categories: [Category]\n    @State private var newCategory = \"\"\n\n    var body: some View {\n        VStack(spacing: 12) {\n            TextField(\"Kategorie\", text: $newCategory)\n                .textFieldStyle(.roundedBorder)\n\n            Button(\"Hinzuf√ºgen\") {\n                let cat = Category(name: newCategory)\n                context.insert(cat)\n                try? context.save()\n                newCategory = \"\"\n            }\n            .buttonStyle(.borderedProminent)\n\n            List(categories) { cat in\n                NavigationLink(destination: ItemListView(category: cat)) {\n                    Text(cat.name)\n                }\n            }\n        }\n        .padding()\n    }\n}\n\nstruct ItemListView: View {\n    @Environment(\\.modelContext) private var context\n    @Bindable var category: Category\n    @State private var newItem = \"\"\n\n    var body: some View {\n        VStack(spacing: 12) {\n            TextField(\"Neuer Eintrag\", text: $newItem)\n                .textFieldStyle(.roundedBorder)\n\n            Button(\"Speichern\") {\n                category.items.append(Item(title: newItem))\n                try? context.save()\n                newItem = \"\"\n            }\n            .buttonStyle(.borderedProminent)\n\n            List(category.items) { item in\n                Text(item.title)\n            }\n        }\n        .padding()\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#560BAD"
  },
  {
    "id": "swiftdata_003",
    "title": "Dynamische Filter mit @Query & Predicate",
    "description": "Filtere SwiftData-Eintr√§ge zur Laufzeit ‚Äì perfekt f√ºr Suchfelder.",
    "steps": [
      "Verwende @Query mit einem dynamischen Predicate.",
      "Nutze ein Suchfeld, um live zu filtern.",
      "Predicate werden automatisch neu berechnet."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#B5179E", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass Product {\n    var title: String\n    init(_ title: String) { self.title = title }\n}\n\nstruct ProductSearchView: View {\n    @Environment(\\.modelContext) private var context\n    @State private var query = \"\"\n\n    @Query private var products: [Product]\n\n    init() {\n        _products = Query(sort: \\Product.title)\n    }\n\n    var filtered: [Product] {\n        if query.isEmpty { return products }\n        return products.filter { $0.title.lowercased().contains(query.lowercased()) }\n    }\n\n    var body: some View {\n        VStack(spacing: 12) {\n            TextField(\"Suche\", text: $query)\n                .textFieldStyle(.roundedBorder)\n\n            List(filtered) { product in\n                Text(product.title)\n            }\n\n            Button(\"Beispiel hinzuf√ºgen\") {\n                context.insert(Product(\"Item \\(Int.random(in: 1...99))\"))\n                try? context.save()\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#B5179E"
  },
  {
    "id": "swiftdata_004",
    "title": "SwiftData Migration (Model√§nderungen)",
    "description": "Lerne, wie du neue Felder, Defaults oder Umstrukturierungen in deinen Modellen vornimmst.",
    "steps": [
      "F√ºge neue Properties in deinem @Model hinzu.",
      "Nutze Default-Werte zur einfachen Migration.",
      "Die Migration passiert automatisch beim App-Start."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#3A0CA3", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftData\n\n@Model\nclass Player {\n    var name: String\n    var level: Int / üÜï neues Feld\n    var xp: Int = 0 / üÜï Default -> automatische Migration\n\n    init(name: String, level: Int = 1) {\n        self.name = name\n        self.level = level\n    }\n}\n\n/ Keine zus√§tzliche Konfiguration n√∂tig ‚Äì SwiftData migriert automatisch.",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#3A0CA3"
  },
  {
    "id": "swiftdata_005",
    "title": "Undo & Redo mit ModelContext",
    "description": "SwiftData unterst√ºtzt Undo/Redo automatisch mit dem UndoManager aus SwiftUI.",
    "steps": [
      "Hole dir den UndoManager aus @Environment.",
      "Rufe undo() oder redo() auf.",
      "Alle SwiftData-√Ñnderungen sind automatisch integriert."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#4CC9F0", "#000000"],
        "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass TaskItem {\n    var title: String\n    init(_ title: String) { self.title = title }\n}\n\nstruct UndoExampleView: View {\n    @Environment(\\.modelContext) private var context\n    @Environment(\\.undoManager) private var undoManager\n    @Query private var tasks: [TaskItem]\n    @State private var title = \"\"\n\n    var body: some View {\n        VStack(spacing: 10) {\n            TextField(\"Neue Aufgabe\", text: $title)\n                .textFieldStyle(.roundedBorder)\n\n            Button(\"Speichern\") {\n                context.insert(TaskItem(title))\n                try? context.save()\n            }\n            .buttonStyle(.borderedProminent)\n\n            HStack {\n                Button(\"‚Ü©Ô∏è Undo\") { undoManager?.undo() }\n                Button(\"‚Ü™Ô∏è Redo\") { undoManager?.redo() }\n            }\n\n            List(tasks) { task in\n                Text(task.title)\n            }\n        }\n        .padding()\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#4CC9F0"
  },
  {
    "id": "swiftdata_006",
    "title": "SwiftData Performance ‚Äì Batch Insert & Delete",
    "description": "F√ºr gro√üe Datenmengen brauchst du schnelle Sammeloperationen. Nutze context.insert() in Schleifen und l√∂sche mit .delete() effizient.",
    "steps": [
      "Erstelle viele Modelle mit einer Schleife.",
      "Nutze context.save() erst am Ende.",
      "Verwende context.delete(model) zum Entfernen."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#7209B7", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass LogEntry {\n    var message: String\n    init(_ message: String) { self.message = message }\n}\n\nstruct PerformanceView: View {\n    @Environment(\\.modelContext) private var context\n    @Query private var logs: [LogEntry]\n\n    var body: some View {\n        VStack(spacing: 12) {\n            Button(\"100 Eintr√§ge hinzuf√ºgen\") {\n                for i in 1...100 {\n                    context.insert(LogEntry(\"Entry #\\(i)\"))\n                }\n                try? context.save()\n            }\n            .buttonStyle(.borderedProminent)\n\n            Button(\"Alles l√∂schen\") {\n                logs.forEach { context.delete($0) }\n                try? context.save()\n            }\n            .buttonStyle(.bordered)\n\n            List(logs) { log in\n                Text(log.message)\n            }\n        }\n        .padding()\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#7209B7"
  },
  {
    "id": "swiftdata_007",
    "title": "Sortierung & Pagination",
    "description": "Sortiere SwiftData-Eintr√§ge und lade nur eine begrenzte Anzahl ‚Äì ideal f√ºr Chats, Leaderboards oder gro√üe Listen.",
    "steps": [
      "Nutze Query(sort: ...) f√ºr Sortierung.",
      "Begrenze die Anzahl mit fetchLimit.",
      "F√ºr Pagination mehrere Queries verwenden."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#4895EF", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass Message {\n    var text: String\n    var createdAt: Date = .now\n    init(_ text: String) { self.text = text }\n}\n\nstruct MessageListView: View {\n    @Query(sort: \\Message.createdAt, order: .reverse, fetchLimit: 20)\n    private var recentMessages: [Message]\n\n    var body: some View {\n        List(recentMessages) { msg in\n            Text(msg.text)\n        }\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#4895EF"
  },
  {
    "id": "swiftdata_008",
    "title": "Async/Await mit SwiftData",
    "description": "Verarbeite gro√üe Datens√§tze im Hintergrund ‚Äì vermeide UI-Lags und steigere Performance.",
    "steps": [
      "Nutze Task { ... } f√ºr Hintergrundarbeit.",
      "insert() oder delete() in Tasks aufrufen.",
      "Danach context.save() ausf√ºhren."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#30D158", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass LogEntry {\n    var text: String\n    init(_ text: String) { self.text = text }\n}\n\nstruct AsyncInsertView: View {\n    @Environment(\\.modelContext) private var context\n\n    var body: some View {\n        Button(\"1000 Eintr√§ge async speichern\") {\n            Task {\n                for i in 0..<1000 {\n                    context.insert(LogEntry(\"Entry #\\(i)\"))\n                }\n                try? context.save()\n            }\n        }\n        .buttonStyle(.borderedProminent)\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#30D158"
  },
  {
    "id": "swiftdata_009",
    "title": "Many-to-Many Beziehungen",
    "description": "Erstelle zwei Modelle, die sich gegenseitig referenzieren ‚Äì z. B. Spieler, die an mehreren Events teilnehmen.",
    "steps": [
      "Verwende @Relationship(inverse:) f√ºr bidirektionale Beziehungen.",
      "Both-Side Arrays f√ºr Many-to-Many definieren.",
      "Daten automatisch √ºber SwiftData synchronisieren lassen."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#F72585", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftData\n\n@Model\nclass Player {\n    var name: String\n    @Relationship(inverse: \\Event.players) var events: [Event] = []\n    init(_ name: String) { self.name = name }\n}\n\n@Model\nclass Event {\n    var title: String\n    @Relationship var players: [Player] = []\n    init(_ title: String) { self.title = title }\n}\n\n/ Eintragen\nevent.players.append(player)\nplayer.events.append(event)",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#F72585"
  },
  {
    "id": "swiftdata_010",
    "title": "SwiftData + @Bindable",
    "description": "Bearbeite SwiftData-Modelle direkt in der UI ‚Äì ohne extra ViewModels.",
    "steps": [
      "@Bindable in der View verwenden.",
      "√Ñnderungen werden automatisch persistiert.",
      "Ideal f√ºr Edit-Formulare und Settings."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#3A0CA3", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass UserProfile {\n    var username: String = \"\"\n    var bio: String = \"\"\n}\n\nstruct EditProfileView: View {\n    @Bindable var user: UserProfile\n\n    var body: some View {\n        Form {\n            TextField(\"Benutzername\", text: $user.username)\n            TextField(\"Bio\", text: $user.bio)\n        }\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#3A0CA3"
  },
  {
    "id": "swiftdata_011",
    "title": "SwiftData Export & JSON Backup",
    "description": "Exportiere Daten als JSON ‚Äì ideal f√ºr Backups, Debugging oder Cloud-Sync.",
    "steps": [
      "Model-Daten abrufen.",
      "Codierbares Mirror-Struct erstellen.",
      "Daten als JSON speichern oder teilen."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#B5179E", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass Savegame {\n    var stage: Int\n    var level: Int\n    var xp: Int\n    init(stage: Int, level: Int, xp: Int) {\n        self.stage = stage\n        this.level = level\n        this.xp = xp\n    }\n}\n\nstruct ExportView: View {\n    @Query private var saves: [Savegame]\n\n    var body: some View {\n        Button(\"JSON Exportieren\") {\n            if let first = saves.first {\n                let dict: [String: Any] = [\n                    \"stage\": first.stage,\n                    \"level\": first.level,\n                    \"xp\": first.xp\n                ]\n                if let json = try? JSONSerialization.data(withJSONObject: dict, options: .prettyPrinted) {\n                    print(String(decoding: json, as: UTF8.self))\n                }\n            }\n        }\n        .buttonStyle(.borderedProminent)\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#B5179E"
  }
]
