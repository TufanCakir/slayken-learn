[
    {
        "id": "optinal_001",
        "title": "Optionals verstehen",
        "description":
            "Erfahre, wie Optionals in Swift funktionieren und wie man sie sicher entpackt.",
        "steps": [
            "Deklariere eine optionale Variable",
            "√úberpr√ºfe mit if let",
            "Nutze optional chaining"
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF6D2D",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "var name: String? = \"Tufan\"\nif let unwrapped = name { print(unwrapped) }",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF6D2D"
    },
    {
        "id": "struct_001",
        "title": "Structs verstehen",
        "description":
            "Lerne, wie man in Swift Strukturen erstellt, um eigene Datentypen zu definieren.",
        "steps": [
            "Struct mit `struct`-Keyword deklarieren.",
            "Eigene Properties und Methoden hinzuf√ºgen.",
            "Instanz erzeugen und auf Eigenschaften zugreifen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF9F0A",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "struct User {\n    var name: String\n    var age: Int\n\n    func greet() {\n        print(\"Hallo, \\(name)!\")\n    }\n}\n\nlet person = User(name: \"Tufan\", age: 30)\nperson.greet()",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF6D2D"
    },
    {
        "id": "class_001",
        "title": "Klassen & Vererbung",
        "description":
            "Lerne den Unterschied zwischen Klassen und Structs und wie Vererbung funktioniert.",
        "steps": [
            "Klasse mit `class`-Keyword erstellen.",
            "Eigenschaften & Methoden definieren.",
            "Unterklasse ableiten und √ºberschreiben."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF375F",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "class Animal {\n    var name: String\n    init(name: String) { self.name = name }\n    func makeSound() { print(\"üêæ Ger√§usch\") }\n}\n\nclass Dog: Animal {\n    override func makeSound() { print(\"üê∂ Wuff!\") }\n}\n\nlet dog = Dog(name: \"Bello\")\ndog.makeSound()",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF6D2D"
    },
    {
        "id": "enum_001",
        "title": "Enums & Switch",
        "description":
            "Nutze Aufz√§hlungstypen (Enums) f√ºr feste Wertemengen und kombiniere sie mit Switch.",
        "steps": [
            "Enum mit `enum`-Keyword deklarieren.",
            "F√§lle definieren.",
            "Switch verwenden, um je nach Wert zu reagieren."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#5E5CE6",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "enum Direction {\n    case north, south, east, west\n}\n\nlet move = Direction.north\n\nswitch move {\ncase .north: print(\"‚¨ÜÔ∏è Norden\")\ncase .south: print(\"‚¨áÔ∏è S√ºden\")\ncase .east: print(\"‚û°Ô∏è Osten\")\ncase .west: print(\"‚¨ÖÔ∏è Westen\")\n}",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#5E5CE6"
    },
    {
        "id": "protocol_001",
        "title": "Protokolle (Interfaces)",
        "description":
            "Definiere Schnittstellen, die Klassen und Structs implementieren k√∂nnen.",
        "steps": [
            "Protocol mit Anforderungen deklarieren.",
            "Struct oder Class implementieren.",
            "Instanz nutzen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#30D158",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "protocol Greetable {\n    func greet()\n}\n\nstruct Person: Greetable {\n    var name: String\n    func greet() { print(\"Hallo, \\(name)!\") }\n}\n\nlet me = Person(name: \"Tufan\")\nme.greet()",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#30D158"
    },
    {
        "id": "extension_001",
        "title": "Extensions nutzen",
        "description":
            "Erweitere bestehende Typen um neue Funktionen ohne den Original-Code zu ver√§ndern.",
        "steps": [
            "Mit `extension` bestehende Typen erweitern.",
            "Neue Methoden oder Properties hinzuf√ºgen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF9500",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "extension String {\n    var isLong: Bool { self.count > 5 }\n}\n\nprint(\"Hallo\".isLong) // false\nprint(\"Hallo Welt\".isLong) // true",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF9500"
    },
    {
        "id": "error_001",
        "title": "Error Handling",
        "description":
            "Lerne, wie man Fehler in Swift definiert und behandelt.",
        "steps": [
            "Eigenen Error-Typ definieren.",
            "Funktionen mit `throws` markieren.",
            "Mit `do`-`try`-`catch` abfangen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF3B30",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "enum LoginError: Error {\n    case wrongPassword\n}\n\nfunc login(password: String) throws {\n    if password != \"1234\" { throw LoginError.wrongPassword }\n    print(\"‚úÖ Eingeloggt\")\n}\n\ndo {\n    try login(password: \"0000\")\n} catch {\n    print(\"Fehler: \\(error)\")\n}",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF3B30"
    },
    {
        "id": "closure_001",
        "title": "Closures & Funktionen",
        "description":
            "Nutze anonyme Funktionen (Closures) f√ºr Callbacks und Funktionsparameter.",
        "steps": [
            "Closure-Syntax kennenlernen.",
            "Closure an eine Funktion √ºbergeben.",
            "Kurzschreibweise nutzen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF9F0A",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "func fetchData(completion: (String) -> Void) {\n    completion(\"üì¶ Daten geladen\")\n}\n\nfetchData { message in\n    print(message)\n}",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF9F0A"
    },
    {
        "id": "generics_001",
        "title": "Generics verstehen",
        "description":
            "Nutze Generics, um Funktionen und Typen f√ºr verschiedene Datentypen wiederverwendbar zu machen.",
        "steps": [
            "Funktion mit Platzhalter-Typ <T> definieren.",
            "Mit beliebigen Datentypen aufrufen.",
            "Sichert Typpr√ºfung und vermeidet Code-Duplikate."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#BF5AF2",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "func swapValues<T>(_ a: inout T, _ b: inout T) {\n    let temp = a\n    a = b\n    b = temp\n}\n\nvar x = 5\nvar y = 10\nswapValues(&x, &y)\nprint(x, y) // 10 5",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#BF5AF2"
    },
    {
        "id": "asyncawait_001",
        "title": "Async / Await & Concurrency",
        "description":
            "Lerne, wie du asynchrone Aufgaben in Swift mit async/await modern und sicher schreibst.",
        "steps": [
            "Mit async Funktionen erstellen, die await verwenden.",
            "Daten mit URLSession laden.",
            "Fehler mit do-catch behandeln."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#0A84FF",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import SwiftUI\n\nstruct AsyncAwaitExampleView: View {\n    @State private var joke = \"Lade Witz...\"\n\n    var body: some View {\n        VStack(spacing: 20) {\n            Text(joke)\n                .multilineTextAlignment(.center)\n                .padding()\n\n            Button(\"Neuen Witz laden\") {\n                Task { await loadJoke() }\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n\n    func loadJoke() async {\n        guard let url = URL(string: \"https://official-joke-api.appspot.com/random_joke\") else { return }\n        do {\n            let (data, _) = try await URLSession.shared.data(from: url)\n            if let decoded = try? JSONDecoder().decode(Joke.self, from: data) {\n                joke = \"\\(decoded.setup)\\n\\nüí¨ \\(decoded.punchline)\"\n            }\n        } catch {\n            joke = \"Fehler beim Laden üòÖ\"\n        }\n    }\n}\n\nstruct Joke: Codable {\n    let setup: String\n    let punchline: String\n}\n\n#Preview { AsyncAwaitExampleView() }",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#0A84FF"
    },
    {
        "id": "debugging_001",
        "title": "Debugging & Print Statements",
        "description":
            "Lerne, wie du deinen Code mit print(), dump() und Debugging-Werkzeugen besser verstehst.",
        "steps": [
            "Nutze print() f√ºr einfache Ausgaben in der Konsole.",
            "Mit dump() kannst du komplexe Objekte anzeigen.",
            "Verwende #file, #line und #function f√ºr genaue Fehlersuche."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#0A84FF",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "struct User {\n    var name: String\n    var level: Int\n}\n\nlet player = User(name: \"Tufan\", level: 42)\n\nprint(\"üß† Spielername:\", player.name)\ndump(player)\n\nfunc logMessage(_ message: String, file: String = #file, line: Int = #line, function: String = #function) {\n    print(\"[LOG] \\(message) ‚Äî in \\(function) (Zeile \\(line))\")\n}\n\nlogMessage(\"Spiel gestartet\")",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#0A84FF"
    },
    {
        "id": "errorhandling_002",
        "title": "Bug Fix & Fehlerbehandlung",
        "description":
            "So gehst du mit Fehlern um, findest Bugs und verhinderst Abst√ºrze mit do-catch und guard.",
        "steps": [
            "Erstelle eigene Error-Typen.",
            "Nutze do-try-catch f√ºr Fehlerbehandlung.",
            "Verwende guard let, um Fehler fr√ºhzeitig abzufangen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF3B30",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "enum LoginError: Error {\n    case emptyUsername\n    case wrongPassword\n}\n\nfunc login(username: String, password: String) throws {\n    guard !username.isEmpty else { throw LoginError.emptyUsername }\n    guard password == \"1234\" else { throw LoginError.wrongPassword }\n    print(\"‚úÖ Willkommen, \\(username)\")\n}\n\ndo {\n    try login(username: \"Tufan\", password: \"0000\")\n} catch LoginError.emptyUsername {\n    print(\"‚ùå Kein Benutzername angegeben.\")\n} catch LoginError.wrongPassword {\n    print(\"üö´ Falsches Passwort.\")\n} catch {\n    print(\"üî¥ Unbekannter Fehler: \\(error)\")\n}",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF3B30"
    },
    {
        "id": "logging_001",
        "title": "Besseres Logging mit Date und Levels",
        "description":
            "Organisiere Log-Ausgaben mit Zeitstempel und Level (Info, Warnung, Fehler).",
        "steps": [
            "Definiere ein LogLevel-Enum mit verschiedenen Stufen.",
            "Erstelle eine Funktion, die Zeitstempel und Nachricht kombiniert.",
            "Nutze switch, um je nach Level farbige Symbole anzuzeigen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF9500",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nenum LogLevel: String {\n    case info = \"‚ÑπÔ∏è\"\n    case warning = \"‚ö†Ô∏è\"\n    case error = \"üõë\"\n}\n\nfunc log(_ message: String, level: LogLevel = .info) {\n    let date = ISO8601DateFormatter().string(from: Date())\n    print(\"\\(level.rawValue) [\\(date)] - \\(message)\")\n}\n\nlog(\"App gestartet\", level: .info)\nlog(\"Verbindung langsam\", level: .warning)\nlog(\"Server nicht erreichbar\", level: .error)",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF9500"
    },
    {
        "id": "profiling_001",
        "title": "Performance messen mit Zeitstempel",
        "description":
            "Miss die Ausf√ºhrungszeit deines Codes mit CFAbsoluteTime und analysiere langsame Funktionen.",
        "steps": [
            "Verwende CFAbsoluteTimeGetCurrent(), um Start- und Endzeit zu erfassen.",
            "Berechne die Differenz, um die Laufzeit in Sekunden zu erhalten.",
            "Perfekt zum Profilen von Loops oder Netzwerkoperationen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#30D158",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nlet startTime = CFAbsoluteTimeGetCurrent()\n\n// Beispiel: Aufw√§ndige Schleife\nvar result = 0\nfor i in 0..<1_000_000 {\n    result += i\n}\n\nlet endTime = CFAbsoluteTimeGetCurrent()\nlet elapsed = endTime - startTime\n\nprint(\"‚úÖ Ergebnis: \\(result)\")\nprint(String(format: \"‚è± Laufzeit: %.5f Sekunden\", elapsed))",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#30D158"
    },
    {
        "id": "benchmark_001",
        "title": "Array vs Set Benchmark",
        "description":
            "Vergleiche die Geschwindigkeit von Array- und Set-Suchen, um Datenstrukturen besser zu verstehen.",
        "steps": [
            "Erstelle ein gro√ües Array und ein Set mit denselben Elementen.",
            "Suche einen bestimmten Wert mit contains().",
            "Miss die Zeit f√ºr beide Strukturen ‚Äì Sets sind meist deutlich schneller."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#0A84FF",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nlet numbers = Array(0...1_000_000)\nlet numberSet = Set(numbers)\n\nlet target = 999_999\n\nlet startArray = CFAbsoluteTimeGetCurrent()\nlet _ = numbers.contains(target)\nlet endArray = CFAbsoluteTimeGetCurrent()\n\nlet startSet = CFAbsoluteTimeGetCurrent()\nlet _ = numberSet.contains(target)\nlet endSet = CFAbsoluteTimeGetCurrent()\n\nprint(String(format: \"üîç Array-Suche: %.5f s\", endArray - startArray))\nprint(String(format: \"‚ö°Ô∏è Set-Suche: %.5f s\", endSet - startSet))",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#0A84FF"
    },
    {
        "id": "memory_001",
        "title": "Struct vs Class Performance",
        "description":
            "Verstehe den Unterschied zwischen Value Types (Structs) und Reference Types (Classes) in Bezug auf Speicher und Kopien.",
        "steps": [
            "Erstelle ein Struct und eine Class mit denselben Properties.",
            "Teste Kopierverhalten und Speichernutzung.",
            "Structs werden kopiert, Classes referenziert ‚Äì das beeinflusst Performance."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF9500",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nstruct PlayerStruct {\n    var name: String\n    var score: Int\n}\n\nclass PlayerClass {\n    var name: String\n    var score: Int\n    init(name: String, score: Int) {\n        self.name = name\n        self.score = score\n    }\n}\n\nvar structA = PlayerStruct(name: \"Tufan\", score: 100)\nvar structB = structA // Kopie\nstructB.score = 200\nprint(\"Struct A Score: \\(structA.score) ‚Äì Struct B Score: \\(structB.score)\")\n\nlet classA = PlayerClass(name: \"Tufan\", score: 100)\nlet classB = classA // Referenz\nclassB.score = 200\nprint(\"Class A Score: \\(classA.score) ‚Äì Class B Score: \\(classB.score)\")",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF9500"
    },
    {
        "id": "cli_001",
        "title": "Kommandozeilenargumente lesen",
        "description":
            "Lerne, wie du Eingaben aus der Konsole mit CommandLine.arguments verarbeitest, um interaktive Tools zu erstellen.",
        "steps": [
            "Verwende CommandLine.arguments, um √ºbergebene Parameter zu erhalten.",
            "√úberpr√ºfe die Anzahl der Argumente mit count.",
            "Nutze diese Eingaben, um dein Programm dynamisch zu steuern."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#0A84FF",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nlet args = CommandLine.arguments\n\nif args.count < 2 {\n    print(\"‚öôÔ∏è Nutzung: swift main.swift <Name>\")\n} else {\n    let name = args[1]\n    print(\"üëã Hallo, \\(name)! Willkommen in Swift CLI!\")\n}",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#0A84FF"
    },
    {
        "id": "cli_002",
        "title": "Dateien lesen & schreiben",
        "description":
            "Speichere und lade Textdateien in der Konsole, um einfache CLI-Tools zu erstellen.",
        "steps": [
            "Nutze FileManager oder write(to:) zum Schreiben.",
            "Verwende String(contentsOfFile:) zum Lesen.",
            "Fehler mit do-try-catch behandeln, um Abst√ºrze zu vermeiden."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#30D158",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nlet fileURL = URL(fileURLWithPath: \"output.txt\")\nlet text = \"üöÄ Swift CLI schreibt in Dateien!\"\n\ndo {\n    try text.write(to: fileURL, atomically: true, encoding: .utf8)\n    let content = try String(contentsOf: fileURL)\n    print(\"üìÑ Dateiinhalt: \\n\\(content)\")\n} catch {\n    print(\"‚ùå Fehler beim Datei-Zugriff: \\(error)\")\n}",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#30D158"
    },
    {
        "id": "cli_003",
        "title": "JSON verarbeiten in der Konsole",
        "description":
            "Erstelle ein Swift-Tool, das JSON-Dateien liest, decodiert und formatiert ausgibt.",
        "steps": [
            "Definiere eine Codable-Struktur, die das JSON-Schema abbildet.",
            "Nutze JSONDecoder, um die Datei in Swift-Objekte umzuwandeln.",
            "Verwende JSONEncoder, um lesbare JSON-Strings zu erzeugen."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF9500",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nstruct User: Codable {\n    let name: String\n    let age: Int\n}\n\nlet jsonString = \"\"\"{\n    \\\"name\\\": \\\"Tufan\\\",\n    \\\"age\\\": 30\n}\"\"\"\n\nlet data = Data(jsonString.utf8)\n\nif let user = try? JSONDecoder().decode(User.self, from: data) {\n    print(\"‚úÖ Name: \\(user.name), Alter: \\(user.age)\")\n}\n\nif let jsonData = try? JSONEncoder().encode(user),\n   let jsonString = String(data: jsonData, encoding: .utf8) {\n    print(\"\\nüì¶ JSON Ausgabe:\\n\\(jsonString)\")\n}",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF9500"
    },
    {
        "id": "networking_001",
        "title": "Einfache API-Abfrage mit URLSession",
        "description":
            "Lerne, wie du mit URLSession Daten aus dem Internet abrufst und in Swift verwendest.",
        "steps": [
            "Erstelle eine URL und starte eine URLSession dataTask.",
            "Verarbeite die empfangenen Daten als String oder JSON.",
            "Nutze do-try-catch f√ºr sauberes Fehlerhandling."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#0A84FF",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nguard let url = URL(string: \"https://jsonplaceholder.typicode.com/posts/1\") else {\n    fatalError(\"‚ùå Ung√ºltige URL\")\n}\n\nlet task = URLSession.shared.dataTask(with: url) { data, _, error in\n    if let error = error {\n        print(\"üö´ Fehler: \\(error)\")\n        return\n    }\n    if let data = data, let text = String(data: data, encoding: .utf8) {\n        print(\"‚úÖ Antwort:\\n\\(text)\")\n    }\n}\n\ntask.resume()\n\nRunLoop.main.run() // F√ºr CLI-Programme n√∂tig",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#0A84FF"
    },
    {
        "id": "networking_002",
        "title": "API mit Codable & JSONDecoder",
        "description":
            "Lade Daten aus einer API und dekodiere sie direkt in Swift-Strukturen mit Codable.",
        "steps": [
            "Definiere ein Datenmodell mit Codable.",
            "Dekodiere das empfangene JSON mit JSONDecoder.",
            "Verarbeite die Daten im Completion Handler."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#30D158",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nstruct Post: Codable {\n    let id: Int\n    let title: String\n    let body: String\n}\n\nguard let url = URL(string: \"https://jsonplaceholder.typicode.com/posts/1\") else {\n    fatalError(\"‚ùå Ung√ºltige URL\")\n}\n\nURLSession.shared.dataTask(with: url) { data, _, error in\n    guard let data = data else { return }\n    do {\n        let post = try JSONDecoder().decode(Post.self, from: data)\n        print(\"üìù Titel: \\(post.title)\")\n        print(\"üí¨ Inhalt: \\(post.body)\")\n    } catch {\n        print(\"üö´ JSON-Fehler: \\(error)\")\n    }\n}.resume()\n\nRunLoop.main.run()",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#30D158"
    },
    {
        "id": "networking_003",
        "title": "Async/Await API-Call mit Swift Concurrency",
        "description":
            "Verwende async/await f√ºr moderne, saubere API-Aufrufe mit Swift Concurrency.",
        "steps": [
            "Deklariere eine asynchrone Funktion mit async throws.",
            "Nutze URLSession.shared.data(from:) f√ºr den API-Call.",
            "Dekodiere die Daten mit JSONDecoder im modernen Stil."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF9500",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nstruct User: Codable {\n    let id: Int\n    let name: String\n    let email: String\n}\n\nfunc fetchUser() async throws {\n    let url = URL(string: \"https://jsonplaceholder.typicode.com/users/1\")!\n    let (data, _) = try await URLSession.shared.data(from: url)\n    let user = try JSONDecoder().decode(User.self, from: data)\n    print(\"üë§ Nutzer: \\(user.name) ‚Äì üìß \\(user.email)\")\n}\n\nTask {\n    do {\n        try await fetchUser()\n    } catch {\n        print(\"üö´ Fehler: \\(error)\")\n    }\n}\n\nRunLoop.main.run()",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF9500"
    },
    {
        "id": "concurrency_001",
        "title": "TaskGroup & Parallelit√§t",
        "description":
            "Starte mehrere asynchrone Tasks parallel mit TaskGroup und sammle ihre Ergebnisse.",
        "steps": [
            "Verwende `withTaskGroup` f√ºr parallele Aufgaben.",
            "Starte mehrere async Tasks gleichzeitig.",
            "Sammle die Ergebnisse mit `for await` ein."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#0A84FF",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nfunc fetchNumbers() async -> [Int] {\n    await withTaskGroup(of: Int.self) { group in\n        for i in 1...5 {\n            group.addTask {\n                try? await Task.sleep(for: .seconds(Double.random(in: 0.5...2)))\n                print(\"‚úÖ Task \\(i) fertig\")\n                return i * 10\n            }\n        }\n        var results: [Int] = []\n        for await number in group { results.append(number) }\n        return results\n    }\n}\n\nTask {\n    let numbers = await fetchNumbers()\n    print(\"üì¶ Ergebnisse:\", numbers)\n}\n\nRunLoop.main.run()",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#0A84FF"
    },
    {
        "id": "actor_001",
        "title": "Actors verstehen (Thread-Safe State)",
        "description":
            "Actors sch√ºtzen Daten vor Race Conditions bei gleichzeitigen Zugriffen.",
        "steps": [
            "Deklariere einen Actor f√ºr gemeinsame Daten.",
            "Verwende `await`, um sicher auf Properties zuzugreifen.",
            "Ideal f√ºr Multithreading und Concurrency."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#30D158",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nactor ScoreManager {\n    private(set) var score = 0\n    func add(points: Int) {\n        score += points\n    }\n}\n\nlet manager = ScoreManager()\n\nTask {\n    await manager.add(points: 10)\n    await manager.add(points: 5)\n    print(\"üèÜ Aktueller Score: \\(await manager.score)\")\n}\n\nRunLoop.main.run()",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#30D158"
    },
    {
        "id": "taskcancel_001",
        "title": "Tasks abbrechen mit Cancellation",
        "description":
            "Lerne, wie du laufende asynchrone Tasks sicher abbrechen kannst.",
        "steps": [
            "Erstelle einen Task mit Abbruchpr√ºfung.",
            "Nutze `Task.isCancelled`, um Abbruch zu erkennen.",
            "Breche Tasks mit `cancel()` aktiv ab."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#FF3B30",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import Foundation\n\nlet task = Task {\n    for i in 1...10 {\n        try Task.checkCancellation()\n        print(\"‚è≥ Schritt \\(i)\")\n        try await Task.sleep(for: .seconds(0.5))\n    }\n    print(\"‚úÖ Fertig!\")\n}\n\nTask {\n    try await Task.sleep(for: .seconds(2))\n    print(\"üö´ Task wird abgebrochen\")\n    task.cancel()\n}\n\nRunLoop.main.run()",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF3B30"
    },
    {
        "id": "swift_051",
        "title": "Optionals sicher mit guard entpacken",
        "description": "Lerne, wie du mit guard let Optionals sicher fr√ºhzeitig entpackst und Fehlerwege klar trennst.",
        "steps": [
            "nutze guard let f√ºr fr√ºhe R√ºckgaben",
            "halte den Hauptcode sauber",
            "reduziere verschachtelte if-let Bl√∂cke"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#FF6D2D", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "func greet(_ name: String?) {\n    guard let name = name else {\n        print(\"‚ùå Kein Name vorhanden\")\n        return\n    }\n    print(\"üëã Hallo, \\(name)\")\n}\n\ngreet(nil)\ngreet(\"Tufan\")",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF6D2D"
    },
    {
        "id": "swift_052",
        "title": "Computed Properties verstehen",
        "description": "Berechne Werte dynamisch ohne zus√§tzliche Variablen zu speichern.",
        "steps": [
            "berechnete Variable mit get anlegen",
            "Abk√ºrzung verwenden (ohne get {})",
            "ideal f√ºr dynamische Zust√§nde"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#FF9F0A", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "struct Rectangle {\n    var width: Double\n    var height: Double\n\n    var area: Double {\n        width * height\n    }\n}\n\nlet r = Rectangle(width: 10, height: 4)\nprint(r.area)",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF9F0A"
    },
    {
        "id": "swift_053",
        "title": "Property Observers (willSet & didSet)",
        "description": "Verfolge √Ñnderungen an Variablen, um UI oder Logik automatisch zu aktualisieren.",
        "steps": [
            "nutze willSet/didSet",
            "Ideal f√ºr Debugging & UI-Updates",
            "wird vor/nach √Ñnderung ausgef√ºhrt"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#5E5CE6", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "var score: Int = 0 {\n    willSet { print(\"‚û°Ô∏è Neuer Wert: \\(newValue)\") }\n    didSet  { print(\"‚¨ÖÔ∏è Alter Wert: \\(oldValue)\") }\n}\n\nscore = 20\nscore = 50",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#5E5CE6"
    },
    {
        "id": "swift_054",
        "title": "Static Properties & Methods",
        "description": "Nutze statische Werte f√ºr zentrale Konstanten und globale Funktionen.",
        "steps": [
            "mit static deklarieren",
            "Instanz-Erzeugung nicht n√∂tig",
            "perfekt f√ºr Config oder Utils"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#30D158", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "struct MathUtils {\n    static let pi = 3.1415\n    static func square(_ x: Int) -> Int { x * x }\n}\n\nprint(MathUtils.pi)\nprint(MathUtils.square(12))",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#30D158"
    },
    {
        "id": "swift_055",
        "title": "Mutating Functions in Structs",
        "description": "√Ñndere Werte innerhalb eines Structs mit mutating.",
        "steps": [
            "Structs sind immutable ohne mutating",
            "mutating erlaubt Eigenschafts√§nderungen",
            "ideal f√ºr Value Types"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#FF375F", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "struct Counter {\n    var value = 0\n    mutating func add() { value += 1 }\n}\n\nvar c = Counter()\nc.add()\nprint(c.value)",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF375F"
    },
    {
        "id": "swift_056",
        "title": "Lazy Properties korrekt nutzen",
        "description": "Initialisiere Variablen nur bei Bedarf ‚Äì optimal f√ºr Performance.",
        "steps": [
            "mit lazy deklarieren",
            "wird erst beim ersten Zugriff erzeugt",
            "perfekt f√ºr teure Berechnungen"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#FF9500", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "struct DataLoader {\n    lazy var bigData: [Int] = {\n        print(\"üì¶ Lade gro√üe Daten‚Ä¶\")\n        return Array(0...1_000_000)\n    }()\n}\n\nvar loader = DataLoader()\nprint(loader.bigData.count)",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF9500"
    },
    {
        "id": "swift_057",
        "title": "Higher-Order Functions: map / filter / reduce",
        "description": "Verarbeite Listen extrem kompakt mit funktionalen Operationen.",
        "steps": [
            "map ‚Üí transformiere Werte",
            "filter ‚Üí filtere Werte",
            "reduce ‚Üí kombiniere Werte"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#BF5AF2", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "let numbers = [1, 2, 3, 4, 5]\n\nprint(numbers.map { $0 * 2 })\nprint(numbers.filter { $0 % 2 == 0 })\nprint(numbers.reduce(0, +))",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#BF5AF2"
    },
    {
        "id": "swift_058",
        "title": "Subscripts nutzen",
        "description": "Erstelle eigene Zugriffsmethoden wie bei Arrays mit [] Syntax.",
        "steps": [
            "Subscript definieren",
            "Lesen & Schreiben unterst√ºtzen",
            "ideal f√ºr Data-Container"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#FF3B30", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "struct ScoreBoard {\n    var scores = [\"A\": 10, \"B\": 20]\n    subscript(player: String) -> Int? {\n        get { scores[player] }\n        set { scores[player] = newValue }\n    }\n}\n\nvar s = ScoreBoard()\ns[\"A\"] = 99\nprint(s[\"A\"]!)",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#FF3B30"
    },
    {
        "id": "swift_059",
        "title": "Pattern Matching mit if case & guard case",
        "description": "Nutze Pattern Matching, um Enums und Werte extrem sauber zu pr√ºfen.",
        "steps": [
            "if case zum Entpacken nutzen",
            "guard case f√ºr fr√ºhes Verlassen",
            "perfekt f√ºr elegante Switch-Alternativen"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#0A84FF", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "enum Status { case success(Int), error(String) }\nlet response = Status.success(200)\n\nif case let .success(code) = response {\n    print(\"‚úÖ Code: \\(code)\")\n}",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#0A84FF"
    },
    {
        "id": "swift_060",
        "title": "Failable Initializer (init?)",
        "description": "Erstelle Initializer, die nil zur√ºckgeben k√∂nnen ‚Äì perfekt f√ºr Validierung.",
        "steps": [
            "Deklariere init?()",
            "pr√ºfe Werte vor Initialisierung",
            "return nil bei ung√ºltigem Zustand"
        ],
        "colors": {
            "backgroundColors": ["#000000", "#30D158", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code":
            "struct User {\n    let name: String\n    init?(name: String) {\n        guard !name.isEmpty else { return nil }\n        self.name = name\n    }\n}\n\nlet good = User(name: \"Tufan\")\nlet bad = User(name: \"\")\nprint(good)\nprint(bad)",
        "category": "Swift",
        "categoryIcon": "swift",
        "categoryIconColor": "#30D158"
    }
]
