[
  {
    "id": "swiftdata_001",
    "title": "Einf√ºhrung in SwiftData",
    "description": "Lerne, wie du mit SwiftData Objekte speicherst, abrufst und automatisch in SwiftUI synchronisierst.",
    "steps": [
      "Importiere SwiftData und definiere ein @Model.",
      "Erstelle ein ModelContainer im App-Entry.",
      "Nutze @Query oder ModelContext zum Speichern und Laden von Daten."
    ],
    "colors": {
      "backgroundColors": [
        "#000000",
        "#7209B7",
        "#000000"
      ],
      "textColors": [
        "#FFFFFF"
      ]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n// 1Ô∏è‚É£ Datenmodell definieren\n@Model\nclass Note {\n    var title: String\n    var createdAt: Date\n\n    init(title: String, createdAt: Date = .now) {\n        self.title = title\n        self.createdAt = createdAt\n    }\n}\n\n// 2Ô∏è‚É£ Haupt-App mit ModelContainer\n@main\nstruct NotesApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .modelContainer(for: Note.self)\n    }\n}\n\n// 3Ô∏è‚É£ Daten in SwiftUI anzeigen und speichern\nstruct ContentView: View {\n    @Environment(\\.modelContext) private var context\n    @Query private var notes: [Note]\n    @State private var newTitle = \"\"\n\n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 20) {\n                TextField(\"Neue Notiz\", text: $newTitle)\n                    .textFieldStyle(.roundedBorder)\n                    .padding()\n\n                Button(\"Speichern\") {\n                    let note = Note(title: newTitle)\n                    context.insert(note)\n                    try? context.save()\n                    newTitle = \"\"\n                }\n                .buttonStyle(.borderedProminent)\n\n                List(notes) { note in\n                    VStack(alignment: .leading) {\n                        Text(note.title)\n                            .font(.headline)\n                        Text(note.createdAt, style: .date)\n                            .font(.caption)\n                            .foregroundColor(.gray)\n                    }\n                }\n            }\n            .navigationTitle(\"SwiftData Notizen\")\n        }\n    }\n}\n\n#Preview { ContentView() }",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#0000FF"
  },
  {
    "id": "swiftdata_002",
    "title": "SwiftData Beziehungen (One-to-Many)",
    "description": "Erstelle zwei miteinander verkn√ºpfte SwiftData-Modelle ‚Äì z. B. Kategorien mit mehreren Eintr√§gen.",
    "steps": [
      "Erstelle zwei @Model-Klassen.",
      "Verkn√ºpfe sie mithilfe von @Relationship.",
      "Nutze .cascade oder .nullify f√ºr Delete Rules."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#560BAD", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass Category {\n    var name: String\n    @Relationship(deleteRule: .cascade) var items: [Item] = []\n    init(name: String) { self.name = name }\n}\n\n@Model\nclass Item {\n    var title: String\n    init(title: String) { self.title = title }\n}\n\nstruct CategoryListView: View {\n    @Environment(\\.modelContext) private var context\n    @Query private var categories: [Category]\n    @State private var newCategory = \"\"\n\n    var body: some View {\n        VStack(spacing: 12) {\n            TextField(\"Kategorie\", text: $newCategory)\n                .textFieldStyle(.roundedBorder)\n\n            Button(\"Hinzuf√ºgen\") {\n                let cat = Category(name: newCategory)\n                context.insert(cat)\n                try? context.save()\n                newCategory = \"\"\n            }\n            .buttonStyle(.borderedProminent)\n\n            List(categories) { cat in\n                NavigationLink(destination: ItemListView(category: cat)) {\n                    Text(cat.name)\n                }\n            }\n        }\n        .padding()\n    }\n}\n\nstruct ItemListView: View {\n    @Environment(\\.modelContext) private var context\n    @Bindable var category: Category\n    @State private var newItem = \"\"\n\n    var body: some View {\n        VStack(spacing: 12) {\n            TextField(\"Neuer Eintrag\", text: $newItem)\n                .textFieldStyle(.roundedBorder)\n\n            Button(\"Speichern\") {\n                category.items.append(Item(title: newItem))\n                try? context.save()\n                newItem = \"\"\n            }\n            .buttonStyle(.borderedProminent)\n\n            List(category.items) { item in\n                Text(item.title)\n            }\n        }\n        .padding()\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#560BAD"
  },
  {
    "id": "swiftdata_003",
    "title": "Dynamische Filter mit @Query & Predicate",
    "description": "Filtere SwiftData-Eintr√§ge zur Laufzeit ‚Äì perfekt f√ºr Suchfelder.",
    "steps": [
      "Verwende @Query mit einem dynamischen Predicate.",
      "Nutze ein Suchfeld, um live zu filtern.",
      "Predicate werden automatisch neu berechnet."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#B5179E", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass Product {\n    var title: String\n    init(_ title: String) { self.title = title }\n}\n\nstruct ProductSearchView: View {\n    @Environment(\\.modelContext) private var context\n    @State private var query = \"\"\n\n    @Query private var products: [Product]\n\n    init() {\n        _products = Query(sort: \\Product.title)\n    }\n\n    var filtered: [Product] {\n        if query.isEmpty { return products }\n        return products.filter { $0.title.lowercased().contains(query.lowercased()) }\n    }\n\n    var body: some View {\n        VStack(spacing: 12) {\n            TextField(\"Suche\", text: $query)\n                .textFieldStyle(.roundedBorder)\n\n            List(filtered) { product in\n                Text(product.title)\n            }\n\n            Button(\"Beispiel hinzuf√ºgen\") {\n                context.insert(Product(\"Item \\(Int.random(in: 1...99))\"))\n                try? context.save()\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .padding()\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#B5179E"
  },
  {
    "id": "swiftdata_004",
    "title": "SwiftData Migration (Model√§nderungen)",
    "description": "Lerne, wie du neue Felder, Defaults oder Umstrukturierungen in deinen Modellen vornimmst.",
    "steps": [
      "F√ºge neue Properties in deinem @Model hinzu.",
      "Nutze Default-Werte zur einfachen Migration.",
      "Die Migration passiert automatisch beim App-Start."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#3A0CA3", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftData\n\n@Model\nclass Player {\n    var name: String\n    var level: Int // üÜï neues Feld\n    var xp: Int = 0 // üÜï Default -> automatische Migration\n\n    init(name: String, level: Int = 1) {\n        self.name = name\n        self.level = level\n    }\n}\n\n// Keine zus√§tzliche Konfiguration n√∂tig ‚Äì SwiftData migriert automatisch.",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#3A0CA3"
  },
  {
    "id": "swiftdata_005",
    "title": "Undo & Redo mit ModelContext",
    "description": "SwiftData unterst√ºtzt Undo/Redo automatisch mit dem UndoManager aus SwiftUI.",
    "steps": [
      "Hole dir den UndoManager aus @Environment.",
      "Rufe undo() oder redo() auf.",
      "Alle SwiftData-√Ñnderungen sind automatisch integriert."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#4CC9F0", "#000000"],
        "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass TaskItem {\n    var title: String\n    init(_ title: String) { self.title = title }\n}\n\nstruct UndoExampleView: View {\n    @Environment(\\.modelContext) private var context\n    @Environment(\\.undoManager) private var undoManager\n    @Query private var tasks: [TaskItem]\n    @State private var title = \"\"\n\n    var body: some View {\n        VStack(spacing: 10) {\n            TextField(\"Neue Aufgabe\", text: $title)\n                .textFieldStyle(.roundedBorder)\n\n            Button(\"Speichern\") {\n                context.insert(TaskItem(title))\n                try? context.save()\n            }\n            .buttonStyle(.borderedProminent)\n\n            HStack {\n                Button(\"‚Ü©Ô∏è Undo\") { undoManager?.undo() }\n                Button(\"‚Ü™Ô∏è Redo\") { undoManager?.redo() }\n            }\n\n            List(tasks) { task in\n                Text(task.title)\n            }\n        }\n        .padding()\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#4CC9F0"
  },
  {
    "id": "swiftdata_006",
    "title": "SwiftData Performance ‚Äì Batch Insert & Delete",
    "description": "F√ºr gro√üe Datenmengen brauchst du schnelle Sammeloperationen. Nutze context.insert() in Schleifen und l√∂sche mit .delete() effizient.",
    "steps": [
      "Erstelle viele Modelle mit einer Schleife.",
      "Nutze context.save() erst am Ende.",
      "Verwende context.delete(model) zum Entfernen."
    ],
    "colors": {
      "backgroundColors": ["#000000", "#7209B7", "#000000"],
      "textColors": ["#FFFFFF"]
    },
    "code": "import SwiftUI\nimport SwiftData\n\n@Model\nclass LogEntry {\n    var message: String\n    init(_ message: String) { self.message = message }\n}\n\nstruct PerformanceView: View {\n    @Environment(\\.modelContext) private var context\n    @Query private var logs: [LogEntry]\n\n    var body: some View {\n        VStack(spacing: 12) {\n            Button(\"100 Eintr√§ge hinzuf√ºgen\") {\n                for i in 1...100 {\n                    context.insert(LogEntry(\"Entry #\\(i)\"))\n                }\n                try? context.save()\n            }\n            .buttonStyle(.borderedProminent)\n\n            Button(\"Alles l√∂schen\") {\n                logs.forEach { context.delete($0) }\n                try? context.save()\n            }\n            .buttonStyle(.bordered)\n\n            List(logs) { log in\n                Text(log.message)\n            }\n        }\n        .padding()\n    }\n}",
    "category": "SwiftData",
    "categoryIcon": "swiftdata",
    "categoryIconColor": "#7209B7"
  }
]
