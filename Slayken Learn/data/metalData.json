[
    {
        "id": "metal_001",
        "title": "2D Triangle mit Farbverlauf",
        "description":
            "Erstelle dein erstes Metal-Programm mit SwiftUI und MTKView. Dieses Beispiel zeigt, wie du ein einfaches farbiges Dreieck direkt auf der GPU renderst.",
        "steps": [
            "Erstelle eine UIViewRepresentable-Struktur für MetalKit (MTKView).",
            "Implementiere eine Renderer-Klasse, die MTKViewDelegate nutzt.",
            "Erstelle einen Vertex-Buffer mit Position und Farbe.",
            "Richte eine Render-Pipeline mit Vertex- und Fragment-Shadern ein.",
            "Zeichne das Dreieck mit drawPrimitives()."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#0000FF",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import SwiftUI\nimport MetalKit\n\n/ Unsere Haupt-Renderklasse\nfinal class Renderer: NSObject, MTKViewDelegate {\n    var device: MTLDevice!\n    var commandQueue: MTLCommandQueue!\n    var pipelineState: MTLRenderPipelineState!\n    var vertexBuffer: MTLBuffer!\n\n    init(mtkView: MTKView) {\n        super.init()\n        self.device = mtkView.device\n        self.commandQueue = device.makeCommandQueue()\n        \n        / Shader laden\n        let library = device.makeDefaultLibrary()\n        let vertexFunc = library?.makeFunction(name: \"vertex_main\")\n        let fragmentFunc = library?.makeFunction(name: \"fragment_main\")\n\n        / Render Pipeline Setup\n        let pipelineDescriptor = MTLRenderPipelineDescriptor()\n        pipelineDescriptor.vertexFunction = vertexFunc\n        pipelineDescriptor.fragmentFunction = fragmentFunc\n        pipelineDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat\n        pipelineState = try! device.makeRenderPipelineState(descriptor: pipelineDescriptor)\n\n        / Vertexdaten (x, y, z, r, g, b)\n        let vertices: [Float] = [\n            0.0,  0.5, 0.0,  1, 0, 0, / oben (rot)\n           -0.5, -0.5, 0.0,  0, 1, 0, / links (grün)\n            0.5, -0.5, 0.0,  0, 0, 1  / rechts (blau)\n        ]\n        vertexBuffer = device.makeBuffer(bytes: vertices,\n                                         length: MemoryLayout<Float>.size * vertices.count,\n                                         options: [])\n    }\n\n    func draw(in view: MTKView) {\n        guard let drawable = view.currentDrawable,\n              let descriptor = view.currentRenderPassDescriptor else { return }\n        \n        let commandBuffer = commandQueue.makeCommandBuffer()\n        let encoder = commandBuffer?.makeRenderCommandEncoder(descriptor: descriptor)\n        \n        encoder?.setRenderPipelineState(pipelineState)\n        encoder?.setVertexBuffer(vertexBuffer, offset: 0, index: 0)\n        encoder?.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3)\n        \n        encoder?.endEncoding()\n        commandBuffer?.present(drawable)\n        commandBuffer?.commit()\n    }\n\n    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {}\n}\n\nstruct MetalView: UIViewRepresentable {\n    func makeUIView(context: Context) -> MTKView {\n        let view = MTKView()\n        view.device = MTLCreateSystemDefaultDevice()\n        view.clearColor = MTLClearColor(red: 0, green: 0, blue: 0, alpha: 1)\n        let renderer = Renderer(mtkView: view)\n        view.delegate = renderer\n        context.coordinator.renderer = renderer\n        return view\n    }\n\n    func updateUIView(_ uiView: MTKView, context: Context) {}\n    func makeCoordinator() -> Coordinator { Coordinator() }\n\n    class Coordinator {\n        var renderer: Renderer?\n    }\n}",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_002",
        "title": "2D Cube mit Farbverlauf (2 Dreiecke)",
        "description":
            "Erstelle ein farbiges Quadrat in Metal, das aus zwei Dreiecken besteht. Jeder Eckpunkt erhält seine eigene Farbe, wodurch ein Farbverlauf entsteht.",
        "steps": [
            "Erweitere deinen Renderer, um 6 Vertices (2 Dreiecke) zu definieren.",
            "Nutze pro Vertex Position (x, y, z) und Farbe (r, g, b).",
            "Passe drawPrimitives() an, um 6 Vertices zu zeichnen.",
            "Kombiniere die Dreiecke zu einem vollständigen 2D-Quad.",
            "Experimentiere mit Farben und Größen für kreative Effekte."
        ],
        "colors": {
            "backgroundColors": [
                "#000000",
                "#00FF00",
                "#000000"
            ],
            "textColors": [
                "#FFFFFF"
            ]
        },
        "code":
            "import SwiftUI\nimport MetalKit\n\nfinal class Renderer: NSObject, MTKViewDelegate {\n    var device: MTLDevice!\n    var commandQueue: MTLCommandQueue!\n    var pipelineState: MTLRenderPipelineState!\n    var vertexBuffer: MTLBuffer!\n\n    init(mtkView: MTKView) {\n        super.init()\n        device = mtkView.device\n        commandQueue = device.makeCommandQueue()\n        \n        / Shader laden\n        let library = device.makeDefaultLibrary()\n        let vertexFunc = library?.makeFunction(name: \"vertex_main\")\n        let fragmentFunc = library?.makeFunction(name: \"fragment_main\")\n        \n        / Render Pipeline Setup\n        let pipelineDescriptor = MTLRenderPipelineDescriptor()\n        pipelineDescriptor.vertexFunction = vertexFunc\n        pipelineDescriptor.fragmentFunction = fragmentFunc\n        pipelineDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat\n        pipelineState = try! device.makeRenderPipelineState(descriptor: pipelineDescriptor)\n        \n        / Quad (2 Dreiecke → 6 Vertices)\n        let vertices: [Float] = [\n            / Dreieck 1\n            -0.5,  0.5, 0.0,  1, 0, 0,   / oben links – rot\n             0.5,  0.5, 0.0,  0, 1, 0,   / oben rechts – grün\n            -0.5, -0.5, 0.0,  0, 0, 1,   / unten links – blau\n\n            / Dreieck 2\n             0.5,  0.5, 0.0,  0, 1, 0,   / oben rechts – grün\n             0.5, -0.5, 0.0,  1, 1, 0,   / unten rechts – gelb\n            -0.5, -0.5, 0.0,  0, 0, 1    / unten links – blau\n        ]\n        \n        vertexBuffer = device.makeBuffer(bytes: vertices,\n                                         length: MemoryLayout<Float>.stride * vertices.count,\n                                         options: [])\n    }\n\n    func draw(in view: MTKView) {\n        guard let drawable = view.currentDrawable,\n              let descriptor = view.currentRenderPassDescriptor else { return }\n        \n        let commandBuffer = commandQueue.makeCommandBuffer()\n        let encoder = commandBuffer?.makeRenderCommandEncoder(descriptor: descriptor)\n        \n        encoder?.setRenderPipelineState(pipelineState)\n        encoder?.setVertexBuffer(vertexBuffer, offset: 0, index: 0)\n        encoder?.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 6)\n        \n        encoder?.endEncoding()\n        commandBuffer?.present(drawable)\n        commandBuffer?.commit()\n    }\n\n    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {}\n}\n\nstruct MetalView: UIViewRepresentable {\n    func makeUIView(context: Context) -> MTKView {\n        let view = MTKView()\n        view.device = MTLCreateSystemDefaultDevice()\n        view.clearColor = MTLClearColor(red: 0, green: 0, blue: 0, alpha: 1)\n        let renderer = Renderer(mtkView: view)\n        view.delegate = renderer\n        context.coordinator.renderer = renderer\n        return view\n    }\n\n    func updateUIView(_ uiView: MTKView, context: Context) {}\n    func makeCoordinator() -> Coordinator { Coordinator() }\n\n    class Coordinator {\n        var renderer: Renderer?\n    }\n}",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_003",
        "title": "Rotation via Vertex Shader",
        "description": "Füge eine Rotation zu deinem 2D-Objekt hinzu – komplett in der GPU über den Vertex-Shader.",
        "steps": [
            "Erstelle eine Uniform-Struktur für den Rotationswinkel.",
            "Berechne die neue Position im Vertex Shader.",
            "Übergebe Uniforms jedes Frame an die GPU.",
            "Animierte Rotation über Zeit hinzufügen."
        ],
        "colors": {
            "backgroundColors": ["#000000", "#1E90FF", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code": "import SwiftUI\nimport MetalKit\n\nstruct RotatingTriangle: UIViewRepresentable {\n    func makeUIView(context: Context) -> MTKView {\n        let view = MTKView()\n        view.device = MTLCreateSystemDefaultDevice()\n        view.colorPixelFormat = .bgra8Unorm\n\n        let renderer = RotatingRenderer(view: view)\n        view.delegate = renderer\n        context.coordinator.renderer = renderer\n        return view\n    }\n    func updateUIView(_ uiView: MTKView, context: Context) {}\n    func makeCoordinator() -> Coordinator { Coordinator() }\n    class Coordinator { var renderer: RotatingRenderer? }\n}\n\nfinal class RotatingRenderer: NSObject, MTKViewDelegate {\n    var device: MTLDevice!\n    var queue: MTLCommandQueue!\n    var pipeline: MTLRenderPipelineState!\n    var buffer: MTLBuffer!\n    var time: Float = 0\n\n    init(view: MTKView) {\n        super.init()\n        device = view.device\n        queue = device.makeCommandQueue()\n\n        let vertices: [Float] = [ 0,0.5,0,  -0.5,-0.5,0,  0.5,-0.5,0 ]\n        buffer = device.makeBuffer(bytes: vertices, length: vertices.count*4, options: [])\n\n        let lib = device.makeDefaultLibrary()!\n        let pipelineDesc = MTLRenderPipelineDescriptor()\n        pipelineDesc.vertexFunction = lib.makeFunction(name: \"rotating_vertex\")\n        pipelineDesc.fragmentFunction = lib.makeFunction(name: \"color_fragment\")\n        pipelineDesc.colorAttachments[0].pixelFormat = view.colorPixelFormat\n        pipeline = try! device.makeRenderPipelineState(descriptor: pipelineDesc)\n    }\n\n    func draw(in view: MTKView) {\n        time += 0.01\n        guard let drawable = view.currentDrawable,\n              let pass = view.currentRenderPassDescriptor else { return }\n\n        let command = queue.makeCommandBuffer()!\n        let enc = command.makeRenderCommandEncoder(descriptor: pass)!\n        enc.setRenderPipelineState(pipeline)\n        enc.setVertexBuffer(buffer, offset: 0, index: 0)\n        enc.setVertexBytes(&time, length: 4, index: 1)\n        enc.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3)\n        enc.endEncoding()\n        command.present(drawable)\n        command.commit()\n    }\n}\n",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_004",
        "title": "Texturen laden & anzeigen",
        "description": "Render ein Bild (PNG/JPEG) als Textur auf einem Rechteck.",
        "steps": [
            "Eine Textur mit MTKTextureLoader laden.",
            "UV-Koordinaten für jeden Vertex definieren.",
            "Texture Sampler im Fragment Shader verwenden.",
            "Quad mit drawPrimitives() rendern."
        ],
        "colors": {
            "backgroundColors": ["#000000", "#FF1493", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code": "import MetalKit\n\n/ Beispiel: Textur laden\nlet loader = MTKTextureLoader(device: device)\nlet texture = try! loader.newTexture(name: \"example\", scaleFactor: 1, bundle: .main)\n\n/ Fragment Shader:\n/ float4 fragment_main(VertexOut in [[stage_in]], texture2d<float> tex [[texture(0)]]) {\n/     constexpr sampler s(filter::linear);\n/     return tex.sample(s, in.uv);\n/ }",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_005",
        "title": "Depth Buffer (Z-Buffer) aktivieren",
        "description": "Erstelle eine 3D-Szene, in der Objekte korrekt verdeckt werden.",
        "steps": [
            "DepthStencilDescriptor erstellen.",
            "view.depthStencilPixelFormat setzen.",
            "Depth Buffer im RenderPass aktivieren.",
            "Z-Werte für 3D-Vertices setzen."
        ],
        "colors": {
            "backgroundColors": ["#000000", "#00CED1", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code": "/ Aktivieren des Tiefenpuffers:\nview.depthStencilPixelFormat = .depth32Float\n\nlet depthDesc = MTLDepthStencilDescriptor()\ndepthDesc.depthCompareFunction = .less\ndepthDesc.isDepthWriteEnabled = true\nlet depthState = device.makeDepthStencilState(descriptor: depthDesc)",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_006",
        "title": "3D Cube rotieren",
        "description": "Erstelle einen 3D-Würfel aus 36 Vertices und rotiere ihn mit Matrizen.",
        "steps": [
            "Vertex-Struktur mit Position & Farbe erstellen.",
            "Model-View-Projection Matrix berechnen.",
            "rotateX/Y/Z in GPU anwenden.",
            "drawIndexedPrimitives() verwenden."
        ],
        "colors": {
            "backgroundColors": ["#000000", "#9400D3", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code": "/ Beispiel Matrix:\nlet mvp = projection * view * model\nencoder.setVertexBytes(&mvp, length: MemoryLayout<matrix_float4x4>.size, index: 2)",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_007",
        "title": "Compute Shader – GPU Berechnungen",
        "description": "Nutze die GPU, um parallele Berechnungen durchzuführen.",
        "steps": [
            "ComputePipelineState erstellen.",
            "Eingabebuffer & Ausgabebuffer erstellen.",
            "computeEncoder benutzen.",
            "Threads korrekt dispatchen."
        ],
        "colors": {
            "backgroundColors": ["#000000", "#FF8C00", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code": "let computeFunc = library.makeFunction(name: \"compute_main\")!\nlet computePipeline = try device.makeComputePipelineState(function: computeFunc)\n\nlet encoder = commandBuffer.makeComputeCommandEncoder()!\nencoder.setComputePipelineState(computePipeline)\nencoder.setBuffer(inputBuffer, offset: 0, index: 0)\nencoder.setBuffer(outputBuffer, offset: 0, index: 1)\nencoder.dispatchThreadgroups(...)\nencoder.endEncoding()",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_008",
        "title": "Post Processing Shader (Blur)",
        "description": "Füge einen Gaussian Blur im Fragment Shader hinzu.",
        "steps": [
            "Fullscreen Quad rendern.",
            "Kernel-Sampling im Fragment Shader.",
            "Mehrere Texel im Umkreis abtasten.",
            "Resultat mischen (blur)."
        ],
        "colors": {
            "backgroundColors": ["#000000", "#1E1EFF", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code": "/ Fragment Blur Shader:\n/ float4 blur(texture2d<float> tex, float2 uv) {\n/     float2 offsets[5] = {...};\n/     float4 color = float4(0);\n/     for (int i = 0; i < 5; i++) {\n/        color += tex.sample(s, uv + offsets[i]);\n/     }\n/     return color / 5.0;\n/ }",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_009",
        "title": "Instancing – hunderte Objekte zeichnen",
        "description": "Nutze die GPU, um viele Objekte effizient zu rendern.",
        "steps": [
            "Mehrere Transform-Matrizen an Vertex Shader senden.",
            "Instance Count in drawPrimitives setzen.",
            "Shader per instance ID nutzen.",
            "Performance-Optimierung durch shared VertexBuffer."
        ],
        "colors": {
            "backgroundColors": ["#000000", "#00FF7F", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code": "encoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 36, instanceCount: 200)",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
        "id": "metal_010",
        "title": "Metal + SwiftUI Integration (Live Shader)",
        "description": "Verbinde SwiftUI mit live animierten Metal Shadern.",
        "steps": [
            "MTKView über UIViewRepresentable einbetten.",
            "Time Uniform an Shader senden.",
            "SwiftUI State nutzen um Shader Parameter zu ändern.",
            "Perfekte GPU-UI Interaktion."
        ],
        "colors": {
            "backgroundColors": ["#000000", "#C71585", "#000000"],
            "textColors": ["#FFFFFF"]
        },
        "code": "struct ShaderControlView: View {\n    @State private var intensity: Float = 0.5\n    var body: some View {\n        VStack {\n            MetalView(intensity: intensity)\n                .frame(height: 300)\n            Slider(value: $intensity, in: 0...1)\n        }\n    }\n}",
        "category": "Metal",
        "categoryIcon": "cpu",
        "categoryIconColor": "#800080"
    },
    {
      "id": "metal_011",
      "title": "Vertex Normals für 3D Beleuchtung",
      "description": "Lerne, wie du Normalen im Vertex-Shader berechnest und realistische Beleuchtung erzeugst.",
      "steps": [
        "Normalen pro Vertex definieren oder berechnen.",
        "Normal an Fragment Shader übergeben.",
        "Lambert Beleuchtung implementieren.",
        "Lichtfarbe & Intensität dynamisch steuern."
      ],
      "colors": {
        "backgroundColors": ["#000000", "#4682B4", "#000000"],
        "textColors": ["#FFFFFF"]
      },
      "code": "/ Beispiel Fragment Shader für Lambert Lighting:\nfragment float4 lambert_frag(VertexOut in [[stage_in]]) {\n    float3 light = normalize(float3(0.3, 0.8, 1.0));\n    float diffuse = max(dot(in.normal, light), 0.0);\n    return float4(in.color * diffuse, 1.0);\n}",
      "category": "Metal",
      "categoryIcon": "cpu",
      "categoryIconColor": "#800080"
    },
    {
      "id": "metal_012",
      "title": "Shadow Mapping – Echtzeit Schatten",
      "description": "Füge Schatten hinzu, indem du eine Shadow Map aus Sicht der Lichtquelle renderst.",
      "steps": [
        "Render Pass für Shadow Map erstellen.",
        "Depth Texture als Shadow Map nutzen.",
        "Position in Light Space transformieren.",
        "Shadow Vergleich im Fragment Shader nutzen."
      ],
      "colors": {
        "backgroundColors": ["#000000", "#483D8B", "#000000"],
        "textColors": ["#FFFFFF"]
      },
      "code": "/ Shadow Compare\nfloat shadow = depthFromLight + 0.001 < textureDepth ? 1.0 : 0.3;\nreturn float4(color * shadow, 1.0);",
      "category": "Metal",
      "categoryIcon": "cpu",
      "categoryIconColor": "#800080"
    },
    {
      "id": "metal_013",
      "title": "Performance HUD & GPU Profiling aktivieren",
      "description": "Sieh genau, wie viele GPU-ms deine Shader brauchen und optimiere deine Pipelines.",
      "steps": [
        "Metal HUD im Scheme aktivieren.",
        "GPU Frame Time analysieren.",
        "Draw Calls und Threadgroups optimieren.",
        "Pipeline Effizienz steigern."
      ],
      "colors": {
        "backgroundColors": ["#000000", "#228B22", "#000000"],
        "textColors": ["#FFFFFF"]
      },
      "code": "/ Aktivieren in Xcode:\n/ Product → Scheme → Edit Scheme → Diagnostics → Metal → Performance HUD",
      "category": "Metal",
      "categoryIcon": "cpu",
      "categoryIconColor": "#800080"
    },
    {
      "id": "metal_014",
      "title": "Dynamische Vertex- & Uniform-Buffers",
      "description": "Aktualisiere GPU-Buffer jedes Frame für Animation, Physics oder UI-Interaktion.",
      "steps": [
        "Triple Buffering für flüssige Animation nutzen.",
        "setVertexBytes oder setBuffer wählen.",
        "Uniforms pro Frame senden.",
        "Ideal für bewegte Modelle."
      ],
      "colors": {
        "backgroundColors": ["#000000", "#9370DB", "#000000"],
        "textColors": ["#FFFFFF"]
      },
      "code": "encoder.setVertexBytes(&uniforms, length: MemoryLayout<Uniforms>.size, index: 1)\nencoder.setVertexBuffer(dynamicVertexBuffer, offset: 0, index: 0)",
      "category": "Metal",
      "categoryIcon": "cpu",
      "categoryIconColor": "#800080"
    },
    {
      "id": "metal_015",
      "title": "Compute Shader Partikel-System",
      "description": "Erzeuge tausende Partikel (Feuer, Regen, Funken) ausschließlich auf der GPU.",
      "steps": [
        "Buffer für Position, Velocity & Life erstellen.",
        "Compute Shader aktualisiert alle Partikel parallel.",
        "Render Pass zeichnet die Partikel als Punkte.",
        "Perfekt für Schneefall, Funken, Explosionen."
      ],
      "colors": {
        "backgroundColors": ["#000000", "#FF4500", "#000000"],
        "textColors": ["#FFFFFF"]
      },
      "code": "/ Compute Shader (vereinfacht)\nkernel void particle_update(device Particle *particles [[buffer(0)]], uint id [[thread_position_in_grid]]) {\n    particles[id].position += particles[id].velocity * 0.016;\n    particles[id].life -= 0.01;\n}",
      "category": "Metal",
      "categoryIcon": "cpu",
      "categoryIconColor": "#800080"
    }
]
